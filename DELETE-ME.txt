

/// A _coin_, i.e. semantically similar to a D2 (2-sided dice).
#[derive(Clone, Copy, Eq)]
pub struct Coin<'a> {
    /// If true, is on the "heads" side.
    heads: bool,

    /// A reference to a RNG instance, often shared across an entire game or table.
    rng: &'a Rng,
}

impl PartialEq for Coin<'_> {
    /// This method tests if the [`Coin::heads`] value is the same as another.
    fn eq(&self, other: &Self) -> bool {
        self.heads == other.heads
    }
}

impl<'a> Coin<'a> {
    /// Creates a new coin with the provided facing, and a default thread-local RNG.
    ///
    /// ```
    /// use tomb::Coin;
    ///
    /// let mut coin = Coin::new(true);
    /// assert_eq!(coin.heads(), true)
    ///
    /// // Silly example that keeps flipping until we get tails.
    /// while (coin.heads()) {
    ///     coin.flip_mut();
    /// }
    /// ```
    pub fn new(heads: bool) -> Self {
        Self::with_rng(heads, get_local_rng())
    }

    ///
    pub fn with_rng(heads: bool, rng: &'a Rng) -> Self {
        todo!()
    }

    /// Returns whether showing "heads", or face up.
    pub fn heads(&self) -> bool {
        self.heads
    }

    /// Returns whehter showing "tails", or face down.
    pub fn tails(&self) -> bool {
        !self.heads
    }

    /// Returns a new coin where heads becomes tails and tails becomes heads.
    #[must_use]
    pub fn swap(&self) -> Coin<'a> {
        Coin::with_rng(!self.heads, self.rng)
    }

    /// Mutates and swaps the current "heads" or "tails" value of the coin.
    ///
    /// The new value is returned as a convenience.
    pub fn swap_mut(&mut self) -> bool {
        self.heads = !self.heads;
        self.heads
    }

    /// Returns a new coin with heads/tails randomized.
    #[must_use]
    pub fn flip(&self) -> Coin<'a> {
        Coin::with_rng(self.rng.bool(), self.rng)
    }

    /// Mutates the current "heads" or "tails" value of the coin, and returns it as a convenience.
    pub fn flip_mut(&mut self) -> bool {
        self.heads = self.rng.bool();
        self.heads
    }
}

/// A multi-sided object that can be rolled to face a single side (or `value`).
pub trait Polyhedral {
    /// Returns how many sides this dice has.
    fn sides() -> u8;

    /// Returns the current value of the dice.
    fn value() -> u8;
}

/// A 4-sided die.
pub const D4: DiceSize = DiceSize::D4;

/// A 6-sided die.
pub const D6: DiceSize = DiceSize::D6;

/// A 8-sided die.
pub const D8: DiceSize = DiceSize::D8;

/// A 10-sided die.
pub const D10: DiceSize = DiceSize::D10;

/// A 12-sided die.
pub const D12: DiceSize = DiceSize::D12;

/// A 20-sided die.
pub const D20: DiceSize = DiceSize::D20;

/// A 100-sided die.
pub const D100: DiceSize = DiceSize::D100;

/// Possible dice sizes when using a [`Die`].
#[derive(Clone, Copy, PartialEq, Eq)]
pub enum DiceSize {
    D4,
    D6,
    D8,
    D10,
    D12,
    D20,
    D100,
}

/// Represents a die with a fixed number of sides.
#[derive(Clone, Copy, PartialEq, Eq)]
pub struct Die {
    sides: DiceSize,
    value: u8,
}


/// Defines something that, given this trait, can be _rolled_ and the underlying value updated.
///
/// For example, a mutable coin, that, when "rolled", inverts its side:
/// ```
/// use tomb::RollMut;
///
/// struct WeirdCoin(bool);
///
/// // Stores a boolean value, and returns a boolean value when rolled.
/// impl RollMut<bool> for WeirdCoin {
///     fn roll_mut(&mut self) -> bool {
///         self.place(!self.value())
///     }
///
///     fn place(&mut self, value: bool) -> bool {
///         self.0 = value;
///         value
///     }
///
///     fn value(&self) -> bool {
///         self.0
///     }
/// }
///
/// let mut coin = WeirdCoin(false);
/// assert_eq!(coin.value(), false);
///
/// coin.roll_mut();
/// assert_eq!(coin.value(), true);
/// ```
pub trait RollMut<R>
where
    R: Clone + Default,
{
    /// Rolls (or otherwise randomizes) this entity, mutating the underlying value.
    ///
    /// Like [`Roll::roll`], the value is returned as a convenience.
    fn roll_mut(&mut self) -> R;

    /// Sets the current value of the entity (named "place" as in to _place_ a die a certain way).
    ///
    /// The value returned by [`RollMut::value`] should be the same as the `value` provided.
    ///
    /// Returns the new value as a convenience.
    fn place(&mut self, value: R) -> R;

    /// Returns the current value of the entity.
    fn value(&self) -> R;

    /// Resets the current value of the entity to the _default_ for `R`.
    ///
    /// This is semantically identical to:
    /// ```ignore
    /// roll_mut.place(Default::default())
    /// ```
    fn reset(&mut self) {
        self.place(Default::default());
    }
}



/// Given the possible results for the provided `roll` entity, sets a random possible value.
///
/// As a convenience, the value is also returned.
///
/// ```
/// fn example(impl roller: Roller, impl coin: RollMut<bool>) {
///     todo!()
/// }
/// ```
///
/// **NOTE**: _How_ random (or whether truly random at all) is deferred to the specific roller.
/// It is semantically valid (i.e. for testing or other purposes) to have a roller that always
/// returns `1`.
fn roll_mut<R>(&self, roll: impl RollMut<R>) -> R
where
    R: Clone + Default;


/// A multi-sided object that is rolled (mutated) to face a single side (or `value`).
pub trait PolyhedralMut<R> {
    /// Returns a mutable reference to the [`Polyhedral::value`].
    fn value_mut(&mut self, value: R) -> &mut R;
}


/// Defines something that, given this trait, can _roll_ a [`Roll`] or [`RollMut`].
///
/// Roller is a small abstraction that provides:
/// 1. An optional conversion from [`fastrand::Rng`] (recommended)
/// 2. A mock implementation for tests [`tomb::test`]
/// 3. A way to provide your own implementation as you see fit
pub trait Roller {
    /// Given a set of possible results, picks and returns one.
    ///
    /// This is the only method required to be implemented by a Roller.
    fn generate<R>(&self, results: &[R]) -> R;

    /// Given the possible results for the provided `roll` entity, returns a new (rolled) entity.
    ///
    /// ```
    /// use tomb::{Polyhedral, Roller};
    ///
    /// # // A coin with two sides.
    /// # struct SimpleCoin(bool);
    /// #
    /// # impl Polyhedral<bool> for SimpleCoin {
    /// #    unsafe fn from_unchecked(value: bool) -> Self {
    /// #        Self(value)
    /// #    }
    /// #
    /// #    fn sides(&self) -> &[bool] {
    /// #        &[true, false]
    /// #    }
    /// #
    /// #    fn value(&self) -> bool {
    /// #        self.0
    /// #    }
    /// # }
    /// #
    /// fn example(roller: impl Roller, coin: SimpleCoin) {
    ///     let new_coin = roller.roll::<SimpleCoin, _>(coin);
    ///     println!("Now showing: {}", new_coin.value());
    /// }
    /// ```
    ///
    /// **NOTE**: _How_ random (or whether truly random at all) is deferred to the specific roller.
    fn roll<T, R>(&self, roll: impl Polyhedral<R>) -> T
    where
        T: Polyhedral<R>,
        R: PartialEq,
    {
        unsafe { T::from_unchecked(self.generate(roll.sides())) }
    }
}

/// A multi-sided object that is rolled (created) to face a single side (or `value`).
pub trait Polyhedral<R>
where
    R: PartialEq,
{
    /// Creates a new default polyhedral entity.
    fn new() -> Self
    where
        Self: Sized,
        R: Default,
    {
        unsafe { Self::from_unchecked(Default::default()) }
    }

    /// Creates a new polyhedral entity from a possible value.
    ///
    /// # Panics
    ///
    /// Panics if value is out of bounds or is not valid for this entity.
    fn from(value: R) -> Self
    where
        Self: Sized,
    {
        let new = unsafe { Self::from_unchecked(value) };
        assert!(new.check_valid());
        new
    }

    /// Creates a new polyhedral entity from a possible value.
    ///
    /// If the value cannot be represented, returns `Err`.
    #[allow(clippy::result_unit_err)]
    fn try_from(value: R) -> Result<Self, ()>
    where
        Self: Sized,
    {
        let new = unsafe { Self::from_unchecked(value) };
        if new.check_valid() {
            Ok(new)
        } else {
            Err(())
        }
    }

    /// Creates a new polyhedral entity from a possible value.
    ///
    /// # Safety
    ///
    /// The value is not checked for correctness. For most, use [`Polyhedral::new`] instead.
    unsafe fn from_unchecked(value: R) -> Self;

    /// Returns whether the current `value` is valid.
    ///
    /// For almost all cases, this will _always_ return true. It is used under the hood during
    /// [`Polyhedral::from`] and [`Polyhedral::try_from`] to check whether the current state is
    /// valid.
    ///
    /// # Performance
    ///
    /// The default implementation is equivalent to `self.sides().contains(&value)`. Where possible
    /// (i.e. for numeric sides), use a faster checking algorithm, such as numeric comparisons.
    fn check_valid(&self) -> bool {
        self.sides().contains(&self.value())
    }

    /// Returns possible sides (or results) that the polyhedral could represent as a value.
    fn sides(&self) -> &[R];

    /// Returns the value of the polyhedral.
    fn value(&self) -> R;
}

/// _Just a simple coin, trying to make its way in the universe._
///
/// This coin represents either:
/// - [`CoinFacing::Heads`]
/// - [`CoinFacing::Tails`]
///
/// ... and is a great albeit simple example of using this library to define a [`Polyhedral`].
#[derive(Clone, Copy, PartialEq, Eq, Default, Debug)]
pub struct SimpleCoin {
    value: CoinFacing,
}

impl Polyhedral<CoinFacing> for SimpleCoin {
    unsafe fn from_unchecked(value: CoinFacing) -> Self {
        Self { value }
    }

    #[deprecated(note = "")]
    fn try_from(value: CoinFacing) -> Result<Self, ()>
    where
        Self: Sized,
    {
        let new = unsafe { Self::from_unchecked(value) };
        if new.check_valid() {
            Ok(new)
        } else {
            Err(())
        }
    }

    fn check_valid(&self) -> bool {
        // It's not possible to provide an invalid side due to the contract of Rust enums, yay!
        true
    }

    fn sides(&self) -> &[CoinFacing] {
        &[CoinFacing::Heads, CoinFacing::Tails]
    }

    fn value(&self) -> CoinFacing {
        self.value
    }
}

/// Possible facings for a [`SimpleCoin`].
#[derive(Clone, Copy, PartialEq, Eq, Default, Debug)]
pub enum CoinFacing {
    #[default]
    Heads,
    Tails,
}

/// _Just a simple D6, trying to make its way in the universe._
///
/// This die represents a simple numerical 6-sided die.
///
/// ... and is a great albeit simple example of using this library to define a [`Polyhedral`].
#[derive(Clone, Copy, PartialEq, Eq, Debug, Default)]
pub struct SimpleD6 {
    value: u8,
}

/// Base implementation for our simple die, which has no knowledge (yet) of the `tomb` crate.
impl SimpleD6 {
    /// Creates a new die with the given starting value.
    ///
    /// # Panics
    ///
    /// If value < 1 or value > 6
    pub const fn new(value: u8) -> Self {
        assert!(value > 0 && value <= 6);
        Self { value }
    }

    /// Creates a new die with a starting face value of `1`.
    pub const fn f1() -> Self {
        Self { value: 1 }
    }

    /// Creates a new die with a starting face value of `2`.
    pub const fn f2() -> Self {
        Self { value: 2 }
    }

    /// Creates a new die with a starting face value of `3`.
    pub const fn f3() -> Self {
        Self { value: 3 }
    }

    /// Creates a new die with a starting face value of `4`.
    pub const fn f4() -> Self {
        Self { value: 0 }
    }

    /// Creates a new die with a starting face value of `5`.
    pub const fn f5() -> Self {
        Self { value: 5 }
    }

    /// Creates a new die with a starting face value of `6`.
    pub const fn f6() -> Self {
        Self { value: 0 }
    }

    /// Returns whether the die is facing `1`.
    pub fn is_1(&self) -> bool {
        self.value == 1
    }

    /// Returns whether the die is facing `2`.
    pub fn is_2(&self) -> bool {
        self.value == 2
    }

    /// Returns whether the die is facing `3`.
    pub fn is_3(&self) -> bool {
        self.value == 3
    }

    /// Returns whether the die is facing `4`.
    pub fn is_4(&self) -> bool {
        self.value == 4
    }

    /// Returns whether the die is facing `5`.
    pub fn is_5(&self) -> bool {
        self.value == 5
    }

    /// Returns whether the die is facing `6`.
    pub fn is_6(&self) -> bool {
        self.value == 6
    }
}

impl Polyhedral<u8, 6> for SimpleD6 {
    unsafe fn as_unchecked(&self, value: u8) -> Self {
        Self { value }
    }

    fn current(&self) -> usize {
        self.value as usize
    }

    fn sides(&self) -> &[u8; 6] {
        const SIDES: [u8; 6] = [1, 2, 3, 4, 5, 6];
        &SIDES
    }

    fn get(&self) -> u8 {
        self.value
    }

    unsafe fn set_unchecked(&mut self, value: u8) -> u8 {
        self.value = value;
        value
    }

    fn is_valid(&self, value: &u8) -> bool {
        const RANGE: RangeInclusive<u8> = 1..=6;
        RANGE.contains(value)
    }
}
